<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Generatore Strutture Pompe e Valvole</title>
  <!-- v1.2 - Import fix deployment -->
  <script src="https://cdn.tailwindcss.com?v=1.2"></script>
  <script crossorigin src="https://unpkg.com/react@18.2.0/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18.2.0/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/lucide@0.294.0/dist/umd/lucide.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://unpkg.com/xlsx/dist/xlsx.full.min.js"></script>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
// inlined app.js (clean, unescaped)
const { useState, useEffect } = React;
// Correggiamo l'uso delle icone Lucide
const { createIcons, icons } = lucide;
// Inizializziamo le icone
createIcons();

// Global error handlers to surface runtime errors (helps debugging "pagina bianca")
window.addEventListener('error', (e) => {
  console.error('Runtime error catturato:', e.error || e.message, e);
  try {
    // preferiamo mostrare il messaggio nell'interfaccia se l'app è montata
    const msg = 'Errore runtime: ' + (e.error && e.error.message ? e.error.message : e.message);
    try {
      if (window && typeof window.showMessage === 'function') {
        window.showMessage(msg, 'error');
      } else {
        console.error(msg);
      }
    } catch (err) {
      console.error(msg);
    }
  } catch (err) {
    // ignore
  }
});
window.addEventListener('unhandledrejection', (ev) => {
  console.error('Unhandled promise rejection:', ev.reason);
  try {
    const msg = 'Unhandled promise rejection: ' + (ev.reason && ev.reason.message ? ev.reason.message : String(ev.reason));
    if (window && typeof window.showMessage === 'function') {
      window.showMessage(msg, 'error');
    } else {
      console.error(msg);
    }
  } catch (err) {
    console.error(ev.reason);
  }
});

// Definizione della funzione showMessage per mostrare messaggi nella console o nell'interfaccia utente
function showMessage(message, type = 'info') {
  console.log(`[${type.toUpperCase()}] ${message}`);
}

// Definizione della funzione computeHeaderMap per calcolare la mappa degli header
function computeHeaderMap(headers) {
  const map = {};
  headers.forEach((header, index) => {
    const key = header.toLowerCase().replace(/\s+/g, '');
    map[key] = index;
  });
  return map;
}

const PumpStructureGenerator = () => {
  const [loggedIn, setLoggedIn] = useState(false);
  const [username, setUsername] = useState('admin');
  const [password, setPassword] = useState('');
  const [componentType, setComponentType] = useState('pump');
  const [hasInverter, setHasInverter] = useState(false);
  const [tableData, setTableData] = useState('');
  const [structure, setStructure] = useState([]);
  const [templateHeader, setTemplateHeader] = useState(null);
  const [templateRows, setTemplateRows] = useState(null);
  const [templateFilename, setTemplateFilename] = useState(null);
  const [templateValid, setTemplateValid] = useState(true);
  const [templateIssues, setTemplateIssues] = useState([]);
  const [templateAOA, setTemplateAOA] = useState(null);
  const [templateHeaderMap, setTemplateHeaderMap] = useState(null);
  const [templateWorkbook, setTemplateWorkbook] = useState(null);
  const [previewRows, setPreviewRows] = useState([]);
  const [importedRows, setImportedRows] = useState([]);
  const [exportFilename, setExportFilename] = useState('Struttura');
  const [exportFilenameEdited, setExportFilenameEdited] = useState(false);
  const [globalMessage, setGlobalMessage] = useState(null);
  const [dropActive, setDropActive] = useState(false);

  // Messaggistica inline (sostituisce tutti gli alert/prompt)
  const showMessage = (text, type = 'info', ttl = 6000) => {
    const payload = { text: String(text || ''), type };
    setGlobalMessage(payload);
    // Also make it available globally for code outside React
    try {
      window.latestAppMessage = payload;
      window.showMessage = (t, ty) => window.dispatchEvent(new CustomEvent('app-message', { detail: { text: t, type: ty || 'info' } }));
    } catch (e) {}
    if (ttl > 0) setTimeout(() => setGlobalMessage(null), ttl);
  };

  // Funzione per caricare il template (prova percorsi alternativi e log chiari)
  const tryLoadTemplate = async (showMsg = false) => {
    const NAME = 'template_excel.xlsx';
    // prova una lista di possibili URL (relative e assolute)
    const candidatePaths = [
      NAME,
      './' + NAME,
      '/' + NAME,
      (window && window.location ? window.location.origin + '/' + NAME : NAME)
    ];

    let lastError = null;
    for (const p of candidatePaths) {
      try {
        console.log('[TEMPLATE] Trying fetch:', p);
        const res = await fetch(p, { cache: 'no-store' });
        if (!res.ok) {
          console.warn('[TEMPLATE] fetch failed for', p, 'status', res.status);
          lastError = new Error(`Fetch ${p} failed: ${res.status}`);
          continue;
        }
        const ab = await res.arrayBuffer();
        const wb = XLSX.read(ab, { type: 'array', cellStyles: true });
        setTemplateWorkbook(wb); // Salva il workbook originale con formattazione
        const first = wb.Sheets[wb.SheetNames[0]];
        const aoa = XLSX.utils.sheet_to_json(first, { header: 1, raw: false });
        if (!aoa || aoa.length === 0) {
          lastError = new Error('Template caricato ma vuoto: ' + p);
          continue;
        }

        const header = aoa[0].map(h => (h === undefined ? '' : String(h)));
        setTemplateHeader(header);
        try {
          setTemplateHeaderMap(computeHeaderMap(header));
        } catch (e) { setTemplateHeaderMap(null); }

        const aoaNormalized = aoa.map(r => (r || []).map(c => (c === undefined ? '' : String(c))));
        setTemplateAOA(aoaNormalized);

        // trova blocco template
        const rows = [];
        for (let i = 1; i < aoaNormalized.length; i++) {
          const r = aoaNormalized[i];
          const allEmpty = (!r || r.length === 0) || r.every(cell => cell === undefined || String(cell).trim() === '');
          if (allEmpty) break;
          rows.push(r.map(c => (c === undefined ? '' : String(c))));
        }
        if (rows.length > 0) setTemplateRows(rows);

        setTemplateFilename(p);

        // validation
        const required = [
          'Tag Name','Data type','Address PLC','ACCESSO','Comment','Stato','RaW min','RaW maX','Unità di misura','Scala min','Scala maX','Modifiche'
        ];
        const normalize = (s) => String(s || '').normalize('NFD').replace(/\u0300-\u036f/g, '').normalize('NFD').replace(/[\u0300-\u036f]/g, '').toLowerCase().replace(/[^a-z0-9]+/g,'');

        const hdrNorm = header.map(h => normalize(h));
        const missing = [];
        required.forEach(r => { if (!hdrNorm.some(hn => hn === normalize(r))) missing.push(r); });
        setTemplateValid(missing.length === 0);
        setTemplateIssues(missing);

        console.log('[TEMPLATE] Caricato con successo da', p, { header, rowsCount: rows.length, missing });
        if (showMsg) {
          showMessage(`Template caricato da ${p} (${rows.length} righe).`, missing.length === 0 ? 'success' : 'warning', 5000);
        }
        return; // successo, non provare altri paths
      } catch (err) {
        console.warn('[TEMPLATE] errore caricamento', p, err);
        lastError = err;
        continue;
      }
    }

    // se arrivo qui significa che tutti i tentativi sono falliti
    console.warn('[TEMPLATE] impossibile caricare automaticamente il template. Ultimo errore:', lastError);
    if (showMsg) {
      showMessage(`Impossibile caricare ${NAME}. Controlla che il file sia nella root del sito.`, 'warning', 8000);
    }
  };

  // Non caricare più il template automaticamente - non è necessario
  // useEffect(() => {
  //   tryLoadTemplate();
  // }, []);

  
  const handleLogin = (e) => {
    e.preventDefault();
    if (username === 'admin' && password === 'jonni') {
      setLoggedIn(true);
    } else {
      showMessage('Credenziali non valide. Riprova.', 'error');
    }
  };

  // Reset completo degli stati e pulizia delle risorse al logout
  const handleLogout = () => {
    try {
      // reset React state
      setLoggedIn(false);
      setUsername('admin');
      setPassword('');
      setComponentType('pump');
      setHasInverter(false);
      setTableData('');
      setStructure([]);
      setTemplateHeader(null);
      setTemplateRows(null);
      setExportFilename('Struttura');
      setExportFilenameEdited(false);
      setGlobalMessage(null);
      setDropActive(false);

      // pulisci l'input file se presente
      try {
        const inp = document.getElementById('excelFile');
        if (inp) inp.value = '';
      } catch (e) {
        console.warn('Impossibile resettare l\'input file:', e);
      }

      // rimuovi eventuali riferimenti globali usati per i messaggi
      try {
        if (window) {
          window.latestAppMessage = null;
          try { delete window.showMessage; } catch(e) { window.showMessage = undefined; }
        }
      } catch (e) {}

      console.log('Logout: stato dell\'app ripristinato alle impostazioni iniziali.');
    } catch (err) {
      console.error('Errore durante il logout/reset:', err);
      // almeno forziamo il logout
      setLoggedIn(false);
    }
  };

  // Funzione per leggere il file importato (Excel o CSV)
  const readImportedFile = (file) => {
    if (!file) {
      console.error('[IMPORT] Nessun file selezionato.');
      return;
    }

    console.log('[IMPORT] File selezionato:', file.name, 'Tipo:', file.type, 'Dimensione:', file.size);

    const reader = new FileReader();
    
    reader.onerror = (error) => {
      console.error('[IMPORT] Errore durante la lettura del file:', error);
      showMessage('Errore durante la lettura del file.', 'error');
    };

    reader.onload = (evt) => {
      try {
        console.log('[IMPORT] File caricato, elaborazione in corso...');
        let data;
        if (file.name.endsWith('.csv')) {
          // Gestione file CSV
          const text = evt.target.result;
          console.log('[IMPORT] Contenuto CSV:', text.substring(0, 200));
          const rows = text.split(/\r\n|\n/)
                         .filter(row => row.trim().length > 0);
          data = rows.map(row => row.split(/[,;\t]/));
          console.log('[IMPORT] Righe CSV parsate:', data.length);
        } else {
          // Gestione file Excel (.xlsx, .xls)
          console.log('[IMPORT] Lettura file Excel...');
          const workbook = XLSX.read(evt.target.result, { type: 'array' });
          console.log('[IMPORT] Fogli disponibili:', workbook.SheetNames);
          const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
          
          // Converti il foglio Excel in array di righe
          const excelRows = XLSX.utils.sheet_to_json(firstSheet, { header: 1 });
          console.log('[IMPORT] Righe Excel totali:', excelRows.length);
          console.log('[IMPORT] Prima riga (header):', excelRows[0]);
          console.log('[IMPORT] Seconda riga (esempio):', excelRows[1]);
          
          // NON rimuovere l'intestazione: leggi dalla prima riga in poi
          data = excelRows
            .filter(row => row && row.length > 0 && row.some(cell => cell !== undefined && String(cell).trim() !== ''));
          console.log('[IMPORT] Righe filtrate:', data.length);
        }
        
        if (!data || data.length === 0) {
          console.error('[IMPORT] Nessun dato valido trovato nel file importato.');
          showMessage('Il file importato non contiene dati validi.', 'error');
          return;
        }

        // Genera la struttura per ciascuna pompa utilizzando solo il nome e l'indirizzo iniziale
        const numericFrom = (s) => {
          if (!s) return null;
          const m = String(s).match(/(\d+[,.]?\d*)/);
          if (!m) return null;
          return parseFloat(m[1].replace(',', '.'));
        };

        const rawStructures = data.map((row, index) => {
          const nome = (row[0] || '').toString().trim();
          const indirizzo = row[2] !== undefined ? row[2].toString().trim() : '';
          console.log(`[IMPORT] Riga ${index}: Nome='${nome}', Indirizzo='${indirizzo}'`);
          return {
            id: index + 1,
            nome: nome,
            indirizzo: indirizzo,
            hasValidAddress: numericFrom(indirizzo) !== null
          };
        });

        console.log('[IMPORT] Strutture grezze lette dal file:', rawStructures);

        // Filtra righe non valide: nome non vuoto E indirizzo numerico valido
        const structures = rawStructures.filter(s => {
          return s.nome && s.nome.length > 0 && s.hasValidAddress;
        });

        console.log('[IMPORT] Strutture filtrate (valide):', structures);

        if (structures.length === 0) {
          console.warn('[IMPORT] Nessuna struttura valida trovata. Verifica il formato del file.');
          showMessage('Nessuna struttura valida trovata nel file. Assicurati che il file contenga:\n- Colonna 1: Nome pompa/valvola\n- Colonna 3: Indirizzo iniziale (formato numerico, es. 100 o 100,0)', 'warning');
          return;
        }

        // Converti la struttura in formato leggibile per l'anteprima
        const formattedData = structures.map(structure => {
          return `ID: ${structure.id}\nNome: ${structure.nome}\nIndirizzo: ${structure.indirizzo}\n`;
        }).join('\n---\n');

        console.log('[IMPORT] Dati formattati:', formattedData);

        // Imposta i dati nella textarea
        setTableData(formattedData);
        setImportedRows(structures);

        // Non generiamo automaticamente la struttura all'import.
        setStructure([]);
        setPreviewRows([]);
        console.log('[IMPORT] Importazione completata con successo! Clicca "Genera Struttura" per creare la struttura.');
        showMessage(`Importate ${structures.length} pompe/valvole con successo! Clicca "Genera Struttura" per procedere.`, 'success');
      } catch (error) {
        console.error('[IMPORT] Errore durante la lettura del file:', error);
        console.error('[IMPORT] Stack trace:', error.stack);
        showMessage('Errore durante la lettura del file: ' + error.message, 'error');
      }
    };

    if (file.name.endsWith('.csv')) {
      reader.readAsText(file);
    } else {
      reader.readAsArrayBuffer(file);
    }
  };

  // Funzione per leggere il file template
  const readTemplateFile = (file) => {
    if (!file) {
      console.error('[TEMPLATE] Nessun file template selezionato.');
      return;
    }

    console.log('[TEMPLATE] File template selezionato:', file.name);

    const reader = new FileReader();
    
    reader.onerror = (error) => {
      console.error('[TEMPLATE] Errore durante la lettura del template:', error);
      showMessage('Errore durante la lettura del template.', 'error');
    };

    reader.onload = (evt) => {
      try {
        console.log('[TEMPLATE] Template caricato, elaborazione in corso...');
        const ab = evt.target.result;
        const wb = XLSX.read(ab, { type: 'array', cellStyles: true });
        setTemplateWorkbook(wb); // Salva il workbook originale con formattazione
        const first = wb.Sheets[wb.SheetNames[0]];
        const aoa = XLSX.utils.sheet_to_json(first, { header: 1, raw: false });
        
        if (!aoa || aoa.length === 0) {
          showMessage('Il template è vuoto o non valido.', 'error');
          return;
        }

        const header = aoa[0].map(h => (h === undefined ? '' : String(h)));
        setTemplateHeader(header);
        try {
          setTemplateHeaderMap(computeHeaderMap(header));
        } catch (e) { setTemplateHeaderMap(null); }

        const aoaNormalized = aoa.map(r => (r || []).map(c => (c === undefined ? '' : String(c))));
        setTemplateAOA(aoaNormalized);

        const rows = [];
        for (let i = 1; i < aoaNormalized.length; i++) {
          const r = aoaNormalized[i];
          const allEmpty = (!r || r.length === 0) || r.every(cell => cell === undefined || String(cell).trim() === '');
          if (allEmpty) break;
          rows.push(r.map(c => (c === undefined ? '' : String(c))));
        }
        if (rows.length > 0) setTemplateRows(rows);

        setTemplateFilename(file.name);

        console.log('[TEMPLATE] Template caricato con successo:', { header, rowsCount: rows.length });
        showMessage(`Template caricato con successo: ${file.name} (${rows.length} righe).`, 'success');
      } catch (error) {
        console.error('[TEMPLATE] Errore durante la lettura del template:', error);
        showMessage('Errore durante la lettura del template: ' + error.message, 'error');
      }
    };

    reader.readAsArrayBuffer(file);
  };

  // Costruisce sia la struttura flat (array di oggetti) che le righe AoA da inserire nel template,
  // a partire dalle pompe fornite (array di { id, nome, indirizzo }). 
  // Questa versione segue rigidamente l'ordine e il numero di campi definiti in STRUCTURE_TEMPLATES
  // per la combinazione device+inverter scelta, calcola gli indirizzi con `addressFromSequence`
  // e mappa i campi nelle colonne del template (se presenti) o nei default headers.
  const buildGeneratedFromPumps = (pumps) => {
    if (!pumps || !pumps.length) return { flat: [], aoa: [] };

    const headers = templateHeader && templateHeader.length ? templateHeader : [
      'Tag Name', 'Data type', 'Address PLC', 'ACCESSO', 'Comment', 'Stato', 'RaW min', 'RaW maX', 'Unità di misura', 'Scala min', 'Scala maX', 'Modifiche'
    ];
    // Use header map if available for robust column indices
    const headerMap = templateHeaderMap || computeHeaderMap(headers);
    const tagIndex = headerMap.tagIndex >= 0 ? headerMap.tagIndex : 0;
    const addrIndex = headerMap.addrIndex >= 0 ? headerMap.addrIndex : 2;
    const dataTypeIdx = headerMap.dataTypeIdx >= 0 ? headerMap.dataTypeIdx : 1;
    const accessIdx = headerMap.accessIdx >= 0 ? headerMap.accessIdx : 3;
    const commentIdx = headerMap.commentIdx >= 0 ? headerMap.commentIdx : 4;

    const flat = [];
    const aoa = [];

    const seqKey = `${componentType === 'pump' ? 'pump' : 'valve'}_${hasInverter ? 'inv' : 'noinv'}`;
    const tmpl = STRUCTURE_TEMPLATES[seqKey] || [];

    // rows per pump = number of template fields for this device type
    const rowsPerPump = tmpl.length;

    pumps.forEach((p, pIdx) => {
      const pumpName = (p.nome || p.name || '').toString();
      const baseRaw = p.indirizzo || p.address || '';

      for (let i = 0; i < rowsPerPump; i++) {
        const tmeta = tmpl[i] || {};

        // costruisci nome tag usando suffisso del template
        const tagName = `${pumpName}${tmeta.suffix || `_r${i}`}`;

        // calcola address usando la sequenza definita (addressFromSequence)
        const addr = addressFromSequence(baseRaw, seqKey, i) || computeAddress(baseRaw, i, 0);

        const flatItem = {
          name: tagName,
          type: tmeta.type || '',
          address: addr,
          access: tmeta.access || '',
          comment: tmeta.comment || '',
          stato: '',
        };

        if (tmeta.rawMin !== undefined) {
          flatItem.rawMin = tmeta.rawMin;
          flatItem.rawMax = tmeta.rawMax;
          flatItem.unit = tmeta.unit;
          flatItem.scalaMin = tmeta.scalaMin;
          flatItem.scalaMax = tmeta.scalaMax;
        }

        flat.push(flatItem);

        // mappa nelle colonne header
        const row = new Array(headers.length).fill('');
        row[tagIndex] = flatItem.name || '';
        row[dataTypeIdx] = flatItem.type || '';
        row[addrIndex] = flatItem.address || '';
        row[accessIdx] = flatItem.access || '';
        row[commentIdx] = flatItem.comment || '';

        const statoIdx = headers.findIndex(h => /stato/i.test(String(h)));
        const rawMinIdx = headers.findIndex(h => /raW min/i.test(String(h)) || /raw min/i.test(String(h)));
        const rawMaxIdx = headers.findIndex(h => /raW maX/i.test(String(h)) || /raw ma/i.test(String(h)));
        const unitIdx = headers.findIndex(h => /unit/i.test(String(h)));
        const scalaMinIdx = headers.findIndex(h => /scala min/i.test(String(h)));
        const scalaMaxIdx = headers.findIndex(h => /scala ma/i.test(String(h)));

        if (statoIdx >= 0) row[statoIdx] = flatItem.stato || '';
        if (rawMinIdx >= 0) row[rawMinIdx] = flatItem.rawMin !== undefined ? flatItem.rawMin : '';
        if (rawMaxIdx >= 0) row[rawMaxIdx] = flatItem.rawMax !== undefined ? flatItem.rawMax : '';
        if (unitIdx >= 0) row[unitIdx] = flatItem.unit || '';
        if (scalaMinIdx >= 0) row[scalaMinIdx] = flatItem.scalaMin !== undefined ? flatItem.scalaMin : '';
        if (scalaMaxIdx >= 0) row[scalaMaxIdx] = flatItem.scalaMax !== undefined ? flatItem.scalaMax : '';

        aoa.push(row);
      }

      // separazione tra pompe (3 righe vuote)
      if (pIdx < pumps.length - 1) {
        aoa.push(new Array(headers.length).fill(''));
        aoa.push(new Array(headers.length).fill(''));
        aoa.push(new Array(headers.length).fill(''));
      }
    });

    return { flat, aoa };
  };

  const handleGenerate = () => {
    // Preferisci usare i dati importati strutturati se presenti; altrimenti prova a parsare la textarea
    let pumps = [];
    if (importedRows && importedRows.length) {
      pumps = importedRows;
    } else if (tableData && tableData.trim()) {
      // parse tableData nello stesso formato usato dal reader
      const sections = tableData.split('---').filter(section => section.trim());
      sections.forEach((section, idx) => {
        const lines = section.split('\n').map(l => l.trim()).filter(Boolean);
        const p = { id: idx + 1, nome: '', indirizzo: '' };
        lines.forEach(line => {
          if (line.includes('Nome:')) p.nome = line.split('Nome:')[1].trim();
          if (line.includes('Indirizzo:')) p.indirizzo = line.split('Indirizzo:')[1].trim();
        });
        if (p.nome && p.indirizzo) pumps.push(p);
      });
    }

    if (!pumps.length) {
      showMessage('Nessun dato disponibile per generare la struttura. Importa o incolla i dati prima di procedere.', 'warning');
      return;
    }

    try {
      const { flat, aoa } = buildGeneratedFromPumps(pumps);
      setStructure(flat);
      setPreviewRows(aoa);
      console.log('[GENERATE] flat length:', flat.length, 'aoa rows:', aoa.length);

      // Se abbiamo un template caricato in memoria, le righe sono pronte per l'export
      if (templateAOA && templateHeader && templateHeader.length) {
        console.log('[GENERATE] Strutture pronte per essere inserite nel template dalla riga 3');
        showMessage(`Generata struttura per ${pumps.length} pompe (${flat.length} righe totali). Clicca "Esporta Excel" per salvare nel template.`, 'success', 4000);
      } else {
        showMessage(`Generata struttura per ${pumps.length} pompe (${flat.length} righe totali). Anteprima pronta.`, 'success', 4000);
      }
    } catch (err) {
      console.error('Errore durante la generazione della struttura:', err);
      showMessage('Errore durante la generazione. Controlla la console.', 'error');
    }
  };

  const handleExport = () => {
    try {
      if (!structure || structure.length === 0) {
        showMessage('Nessuna struttura da esportare. Genera una struttura prima di procedere.', 'warning');
        return;
      }
      console.log('Avvio export', { templateHeader, templateRows, structureLength: structure.length });

      // Stili Excel usati sia nel flusso con template che in quello fallback.
      const headerStyle = {
        fill: { fgColor: { rgb: 'FFFFFFFF' } },
        alignment: { horizontal: 'center', vertical: 'center' },
        font: { bold: true, color: { rgb: 'FFFF0000' } }
      };
      const titleStyle = {
        fill: { fgColor: { rgb: 'FFFFC000' } },
        alignment: { horizontal: 'center', vertical: 'center' },
        font: { bold: true, color: { rgb: 'FF000000' } }
      };
      // Raggruppa gli elementi per pompa
      const pompeMap = {};
      const pumpNamesOrdered = [];
      structure.forEach(item => {
        const pompeName = (item.name && item.name.split ? item.name.split('.')[0] : String(item.name || ''));
        if (!pompeMap[pompeName]) {
          pompeMap[pompeName] = [];
          pumpNamesOrdered.push(pompeName);
        }
        pompeMap[pompeName].push(item);
      });

      // Tutte le colonne che vuoi presenti nel file, anche se vuote
      const defaultHeaders = [
        'Tag Name', 'Data type', 'Address PLC', 'ACCESSO', 'Comment',
        'Stato', 'RaW min', 'RaW maX', 'Unità di misura', 'Scala min', 'Scala maX', 'Modifiche'
      ];

      const headers = templateHeader && templateHeader.length ? templateHeader : defaultHeaders;
      const aoa = [];
      const merges = [];
      // pumpNames visible to whole function (preserve order from structure)
      let pumpNames = pumpNamesOrdered.length ? pumpNamesOrdered : Object.keys(pompeMap);

      // Se abbiamo un template caricato (AOA), usalo come base: altrimenti usa il comportamento precedente
      if (templateAOA && templateHeader && templateHeader.length) {
        // genera solo le righe da inserire (senza header)
        let generatedRows = [];
        if (previewRows && previewRows.length) {
          // usa la preview già generata (consistente col pulsante Genera)
          generatedRows = previewRows.slice();
        } else {
          // prova a costruire le righe a partire dai dati importati
          let pumps = [];
          if (importedRows && importedRows.length) pumps = importedRows;
          else if (tableData && tableData.trim()) {
            const sections = tableData.split('---').filter(section => section.trim());
            sections.forEach((section, idx) => {
              const lines = section.split('\n').map(l => l.trim()).filter(Boolean);
              const p = { id: idx + 1, nome: '', indirizzo: '' };
              lines.forEach(line => {
                if (line.includes('Nome:')) p.nome = line.split('Nome:')[1].trim();
                if (line.includes('Indirizzo:')) p.indirizzo = line.split('Indirizzo:')[1].trim();
              });
              if (p.nome && p.indirizzo) pumps.push(p);
            });
          }
          const built = buildGeneratedFromPumps(pumps);
          generatedRows = built.aoa;
        }

        // Debug: log principali prima di creare AOA
        console.log('[EXPORT] generatedRows:', generatedRows.length, 'pumpNames:', pumpNames);
        if (!generatedRows || generatedRows.length === 0) {
          showMessage('Attenzione: non ci sono righe generate. Verifica di aver cliccato "Genera Struttura" e che i dati importati siano validi.', 'warning', 8000);
          console.warn('[EXPORT] Nessuna riga generata, aborting export.');
          return;
        }

        // Crea il worksheet direttamente con header + riga vuota + dati
        const finalHeaders = ['Tag Name', 'Data type', 'Address PLC', 'ACCESSO', 'Comment', 'Stato', 'RaW min', 'RaW maX', 'Unità di misura', 'Scala min', 'Scala maX', 'Modifiche'];
        const emptyRow = new Array(finalHeaders.length).fill('');
        const allRows = [finalHeaders, emptyRow].concat(generatedRows);
        
        const worksheet = XLSX.utils.aoa_to_sheet(allRows);
        
        // Applica stili all'header (riga 0): testo rosso, centrato, grassetto
        const headerStyle = {
          font: { bold: true, color: { rgb: 'FF0000' } },
          alignment: { horizontal: 'center', vertical: 'center' },
          fill: { fgColor: { rgb: 'FFFFFF' } }
        };
        
        for (let c = 0; c < finalHeaders.length; c++) {
          const cellAddr = XLSX.utils.encode_cell({ c, r: 0 });
          if (worksheet[cellAddr]) {
            worksheet[cellAddr].s = headerStyle;
          }
        }
        
        // Imposta larghezze colonne
        worksheet['!cols'] = [
          { wch: 40 },  // Tag Name
          { wch: 18 },  // Data type
          { wch: 20 },  // Address PLC
          { wch: 12 },  // ACCESSO
          { wch: 40 },  // Comment
          { wch: 12 },  // Stato
          { wch: 12 },  // RaW min
          { wch: 12 },  // RaW maX
          { wch: 18 },  // Unità di misura
          { wch: 12 },  // Scala min
          { wch: 12 },  // Scala maX
          { wch: 40 }   // Modifiche
        ];
        
        // Crea workbook e aggiungi il foglio
        const workbook = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(workbook, worksheet, 'Struttura');

        // Esporta il file
        try {
          let baseName = (exportFilename && String(exportFilename).trim()) ? String(exportFilename).trim() : 'Struttura';
          if (baseName.toLowerCase().endsWith('.xlsx')) baseName = baseName.slice(0, -5);
          const outName = baseName + '.xlsx';
          XLSX.writeFile(workbook, outName, { cellStyles: true });
          showMessage('File esportato con successo: ' + outName, 'success');
        } catch (errWrite) {
          console.error('Errore durante writeFile:', errWrite);
          try { XLSX.writeFile(workbook, 'Struttura.xlsx'); } catch(e){ console.error('Secondo tentativo writeFile fallito:', e); }
          showMessage('File esportato: Struttura.xlsx', 'success');
        }

        // abbiamo già scritto il file: terminiamo qui
        return;
      } else {
        // fallback: comportamento precedente semplice
        const headers = defaultHeaders;
        aoa.push(headers);
        // separazione: una riga vuota tra header e prima struttura
        aoa.push(new Array(headers.length).fill(''));
        // ensure pumpNames in fallback uses object keys order
        pumpNames = Object.keys(pompeMap);
        // Output structure rows directly (no pump title rows)
        pumpNames.forEach((pompeName, pIdx) => {
          pompeMap[pompeName].forEach(item => {
            aoa.push([
              item.name || '',
              item.type || '',
              item.address || '',
              item.access || '',
              item.comment || '',
              item.stato || '',
              item.rawMin !== undefined ? item.rawMin : '',
              item.rawMax !== undefined ? item.rawMax : '',
              item.unit || '',
              item.scalaMin !== undefined ? item.scalaMin : '',
              item.scalaMax !== undefined ? item.scalaMax : '',
              ''
            ]);
          });
          // separazione di almeno 3 righe vuote tra pompe (tranne dopo l'ultima)
          if (pIdx < pumpNames.length - 1) {
            aoa.push(new Array(headers.length).fill(''));
            aoa.push(new Array(headers.length).fill(''));
            aoa.push(new Array(headers.length).fill(''));
          }
        });
      }

      const worksheet = XLSX.utils.aoa_to_sheet(aoa);
      worksheet['!merges'] = merges;

      // Stili applicati (definiti in alto per riuso nel flusso di export)

      // Applica stile all'intestazione in cima (prima riga)
      for (let c = 0; c < headers.length; c++) {
        const cell = XLSX.utils.encode_cell({ c, r: 0 });
        if (worksheet[cell]) worksheet[cell].s = headerStyle;
      }

      // No pump title rows to style (we output structure rows directly)

      // Imposta le larghezze delle colonne dinamicamente in base al numero di headers
      const cols = headers.map((h, i) => {
        if (i === 0 || i === 4 || i === headers.length - 1) return { wch: 40 };
        if (i === 2) return { wch: 20 };
        if (i === 1) return { wch: 18 };
        return { wch: 12 };
      });
      worksheet['!cols'] = cols;

      console.log('Export AOArows:', aoa.length, 'pumpNames:', pumpNames);
      const workbook = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(workbook, worksheet, 'Struttura');

      try {
        const defaultName = 'Struttura';
        let nameBase = (exportFilename && String(exportFilename).trim()) ? String(exportFilename).trim() : defaultName;
        if (nameBase.toLowerCase().endsWith('.xlsx')) {
          nameBase = nameBase.slice(0, -5);
        }
        // Evita di sovrascrivere il template originale: se l'utente ha usato lo stesso nome
        // del template (senza estensione), aggiungiamo un suffisso per sicurezza.
        try {
          if (templateFilename) {
            const tplBase = String(templateFilename).replace(/\.xlsx$/i, '');
            if (tplBase.toLowerCase() === nameBase.toLowerCase()) {
              nameBase = nameBase + '-export';
            }
          }
        } catch (e) { /* ignore */ }

        const filename = nameBase + '.xlsx';
        XLSX.writeFile(workbook, filename);
        showMessage('Struttura esportata con successo!', 'success');
      } catch (errWrite) {
        console.error('Errore durante writeFile:', errWrite);
        try { XLSX.writeFile(workbook, 'Struttura.xlsx'); } catch(e){ console.error('Secondo tentativo writeFile fallito:', e); }
        showMessage('Struttura esportata con successo!', 'success');
      }
    } catch (err) {
      console.error('Errore durante esportazione:', err);
      showMessage('Errore durante l\'esportazione. Controlla la console per dettagli.', 'error');
    }
  };

  // Funzione helper per rendere le icone
  const renderIcon = (name) => {
    return <i className={`lucide lucide-${name}`}></i>;
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 p-6">
      <div className="max-w-7xl mx-auto">
        {globalMessage && (
          <div className={
            `mb-4 p-3 rounded ${globalMessage.type === 'error' ? 'bg-red-100 text-red-800' : globalMessage.type === 'success' ? 'bg-green-100 text-green-800' : globalMessage.type === 'warning' ? 'bg-yellow-100 text-yellow-800' : 'bg-blue-100 text-blue-800'}`
          }>
            {globalMessage.text}
          </div>
        )}
        {!loggedIn ? (
          <div className="bg-white rounded-xl shadow-lg p-8 max-w-md mx-auto">
            <h2 className="text-2xl font-bold mb-4">Login</h2>
            <form onSubmit={handleLogin} className="space-y-4">
              <input 
                value={username} 
                onChange={(e)=>setUsername(e.target.value)} 
                placeholder="Username (admin)" 
                className="w-full p-3 border rounded" 
              />
              <input 
                type="password" 
                value={password} 
                onChange={(e)=>setPassword(e.target.value)} 
                placeholder="Password" 
                className="w-full p-3 border rounded" 
              />
              <div className="flex justify-end gap-2">
                <button type="submit" className="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700">
                  Accedi
                </button>
              </div>
            </form>
          </div>
        ) : (
          <div className="bg-white rounded-xl shadow-lg p-8">
            <div className="flex justify-between items-center mb-6">
              <h1 className="text-3xl font-bold">Generatore Struttura</h1>
              <button onClick={handleLogout} className="bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600">
                Logout
              </button>
            </div>

            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div className="space-y-4">
                <h2 className="text-xl font-semibold">Configurazione</h2>
                <div>
                  <label className="block text-sm font-medium mb-1">Tipologia</label>
                  <select 
                    value={componentType} 
                    onChange={(e) => setComponentType(e.target.value)} 
                    className="w-full p-2 border rounded"
                  >
                    <option value="pump">Pompa</option>
                    <option value="valve">Valvola</option>
                  </select>
                </div>

                <div className="space-y-2">
                  <label className="block text-sm font-medium">Importa Dati Componenti</label>
                  <div className="flex flex-col gap-2">
                    <div
                      id="dropZone"
                      onDragOver={(e) => { e.preventDefault(); e.stopPropagation(); e.dataTransfer.dropEffect = 'copy'; setDropActive(true); }}
                      onDragEnter={(e) => { e.preventDefault(); e.stopPropagation(); setDropActive(true); }}
                      onDragLeave={(e) => { e.preventDefault(); e.stopPropagation(); setDropActive(false); }}
                      onDrop={(e) => { e.preventDefault(); e.stopPropagation(); setDropActive(false); const f = e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files[0]; if (f) readImportedFile(f); }}
                      className={`w-full p-4 rounded flex flex-col items-center justify-center text-sm ${dropActive ? 'border-2 border-green-400 bg-green-50' : 'border-2 border-dashed border-gray-300 bg-white'}`}>
                      <div className="dz-inner flex items-center gap-3">
                        <span className="dz-icon">{renderIcon('cloud')}</span>
                        <div className="text-gray-600 dz-text">Trascina qui il file Excel (.xlsx, .xls), .ods o CSV oppure clicca il pulsante <strong>Importa Excel</strong></div>
                      </div>
                    </div>

                    <input
                      type="file"
                      accept=".xlsx,.xls,.csv,.ods"
                      onChange={(e) => { const file = e.target.files[0]; if (file) readImportedFile(file); }}
                      className="hidden"
                      id="excelFile"
                    />
                    <label
                      htmlFor="excelFile"
                      className="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700 flex items-center gap-2 cursor-pointer justify-center w-full"
                    >
                      {renderIcon('upload')}
                      Importa Excel
                    </label>
                  </div>

                  {/* Preview moved to the main preview panel on the right. */}

                  <div className="mt-4">
                    <label className="block text-sm font-medium mb-2">Oppure Incolla Tabella</label>
                    <textarea
                      className="w-full p-2 border rounded h-32 font-mono text-sm"
                      placeholder="Incolla qui i dati della tabella..."
                      value={tableData}
                      onChange={(e) => setTableData(e.target.value)}
                    ></textarea>
                  </div>
                </div>

                <div>
                  <label className="block text-sm font-medium mb-1">Configurazione Inverter</label>
                  <div className="flex items-center gap-2">
                    <input 
                      type="checkbox" 
                      id="hasInverter" 
                      checked={hasInverter} 
                      onChange={(e) => setHasInverter(e.target.checked)} 
                      className="w-4 h-4" 
                    />
                    <label htmlFor="hasInverter">Dotato di Inverter</label>
                  </div>
                </div>

                <button 
                  onClick={handleGenerate} 
                  className="bg-blue-600 text-white px-6 py-2 rounded hover:bg-blue-700 flex items-center gap-2 w-full justify-center"
                >
                  {renderIcon('play')}
                  Genera Struttura
                </button>
              </div>

              <div className="space-y-4">
                <h2 className="text-xl font-semibold">Anteprima</h2>
                <div className="mt-0 bg-white p-3 rounded border border-gray-200 text-sm text-gray-800 resizable-preview">
                  {previewRows && previewRows.length > 0 ? (
                    <>
                      <div className="mb-2 font-semibold">Righe totali da inserire: {previewRows.length} — (anteprima prime 20)</div>
                      <div className="overflow-x-auto mt-2 font-mono text-xs">
                        <table className="w-full border-collapse">
                          <thead>
                            <tr>
                              {(templateHeader || ['Tag Name','Data type','Address PLC','ACCESSO','Comment','Stato','RaW min','RaW maX','Unità di misura','Scala min','Scala maX','Modifiche']).map((h, i) => (
                                <th key={i} className="px-2 py-1 text-left border-b">{h}</th>
                              ))}
                            </tr>
                          </thead>
                          <tbody>
                            {previewRows.slice(0, 20).map((r, ri) => (
                              <tr key={ri} className={ri % 2 === 0 ? 'bg-gray-50' : ''}>
                                {r.map((c, ci) => <td key={ci} className="px-2 py-1 align-top border-b">{c}</td>)}
                              </tr>
                            ))}
                          </tbody>
                        </table>
                      </div>
                    </>
                  ) : (
                    <div className="bg-gray-100 p-4 rounded-lg h-[320px] overflow-y-auto font-mono text-sm">{tableData ? `Struttura generata con ${structure.length} elementi:\n${structure.map(item => `${item.name} (${item.type})`).join('\n')}` : 'Importa o incolla i dati per vedere l\'anteprima...'}</div>
                  )}
                </div>
                <div className="mt-2">
                  <label className="block text-sm text-gray-600 mb-1">Nome file export</label>
                  <div className="flex items-center gap-2">
                    <input
                      type="text"
                      value={exportFilename}
                      onChange={(e) => {
                        // rimuovi eventuale estensione inserita per evitare che l'utente la modifichi
                        let v = String(e.target.value || '');
                        v = v.replace(/\.xlsx$/i, '').trim();
                        setExportFilename(v);
                        setExportFilenameEdited(true);
                      }}
                      placeholder={'Struttura'}
                      className="flex-1 p-2 border rounded text-sm"
                    />
                    <span className="text-sm text-gray-600">.xlsx</span>
                  </div>
                  <p className="text-xs text-gray-500 mt-1">L'estensione <strong>.xlsx</strong> è fissata e verrà aggiunta automaticamente. Modifica solo il nome base.</p>
                </div>
                <div className="flex gap-2 mt-3">
                  <button 
                    onClick={handleExport}
                    className="bg-orange-600 text-white px-4 py-2 rounded hover:bg-orange-700 flex items-center gap-2 w-full justify-center"
                  >
                    {renderIcon('file-text')}
                    Esporta Excel
                  </button>
                </div>
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

try {
  const root = ReactDOM.createRoot(document.getElementById('root'));
  root.render(<PumpStructureGenerator />);
} catch (renderErr) {
  console.error('Errore durante il render dell\'app:', renderErr);
  try {
    const msg = 'Errore durante il render dell\'app: ' + (renderErr && renderErr.message ? renderErr.message : String(renderErr));
    if (window && typeof window.showMessage === 'function') {
      window.showMessage(msg, 'error');
    } else {
      console.error(msg);
    }
  } catch (e) {}
}

// Definizione di base per STRUCTURE_TEMPLATES
const STRUCTURE_TEMPLATES = {
  pump_inv: [
    { suffix: '.Command.Automatic', type: 'Bool', address: '3118,0', access: 'R/W', comment: 'Comando modalità automatica', scalaMin: 0, scalaMax: 50 },
    { suffix: '.Command.Manual', type: 'Bool', address: '3118,1', access: 'R/W', comment: 'Comando modalità manuale', scalaMin: 0, scalaMax: 50 },
    { suffix: '.Command.Cmd_Man', type: 'Bool', address: '3118,3', access: 'R/W', comment: 'Comando start manuale', scalaMin: 0, scalaMax: 50 },
    { suffix: '.Command.Inv_Speed_Man', type: 'Real', address: '3120,0', access: 'R/W', comment: 'Riferimento manuale velocità inverter', rawMin: 0, rawMax: 50, unit: 'Hz', scalaMin: 0, scalaMax: 50 },
    { suffix: '.Status.Ready', type: 'Bool', address: '3128,0', access: 'R', comment: 'Utenza pronta', scalaMin: 0, scalaMax: 50 },
    { suffix: '.Status.Running', type: 'Bool', address: '3128,2', access: 'R', comment: 'Utenza in marcia', scalaMin: 0, scalaMax: 50 },
    { suffix: '.Status.Automatic', type: 'Bool', address: '3128,3', access: 'R', comment: 'Utenza in modalità automatica', scalaMin: 0, scalaMax: 50 },
    { suffix: '.Status.Manual', type: 'Bool', address: '3128,4', access: 'R', comment: 'Utenza in modalità manuale', scalaMin: 0, scalaMax: 50 },
    { suffix: '.Status.Selector', type: 'Bool', address: '3128,5', access: 'R', comment: 'Selettore utenza in remoto', scalaMin: 0, scalaMax: 50 },
    { suffix: '.Monitor.Frequency_Fbk', type: 'Real', address: '3130,0', access: 'R', comment: 'Feedback frequenza inverter', rawMin: 0, rawMax: 50, unit: 'Hz', scalaMin: 0, scalaMax: 50 },
    { suffix: '.Monitor.Current', type: 'Real', address: '3134,0', access: 'R', comment: 'Feedback corrente', rawMin: 0, rawMax: 999, unit: 'A', scalaMin: 0, scalaMax: 999 },
    { suffix: '.Monitor.Power', type: 'Real', address: '3138,0', access: 'R', comment: 'Feedback potenza', rawMin: 0, rawMax: 999, unit: 'Kw', scalaMin: 0, scalaMax: 999 },
    { suffix: '.Monitor.Voltage', type: 'Real', address: '3142,0', access: 'R', comment: 'Feedback Tensione inverter', rawMin: 0, rawMax: 9999, unit: 'V', scalaMin: 0, scalaMax: 9999 },
    { suffix: '.Worktime.Reset', type: 'Bool', address: '3162,0', access: 'R/W', comment: 'Comando reset ore parziali utenza' },
    { suffix: '.Worktime.Total.Hour', type: 'DInt', address: '3164,0', access: 'R', comment: 'Ore totali', rawMin: 0, rawMax: 9999999, unit: 'Min', scalaMin: 0, scalaMax: 9999999 },
    { suffix: '.Worktime.Total.Min', type: 'Int', address: '3168,0', access: 'R', comment: 'Minuti totali', rawMin: 0, rawMax: 59, unit: 'Min', scalaMin: 0, scalaMax: 59 },
    { suffix: '.Worktime.Partial.Hour', type: 'DInt', address: '3172,0', access: 'R', comment: 'Ore Parziali', rawMin: 0, rawMax: 9999999, unit: 'Min', scalaMin: 0, scalaMax: 9999999 },
    { suffix: '.Worktime.Partial.Min', type: 'Int', address: '3176,0', access: 'R', comment: 'Minuti Parziali', rawMin: 0, rawMax: 59, unit: 'Min', scalaMin: 0, scalaMax: 59 }
  ],
  pump_noinv: [
    { suffix: '.Command.Automatic', type: 'Bool', address: '3118,0', access: 'R/W', comment: 'Comando modalità automatica' },
    { suffix: '.Command.Manual', type: 'Bool', address: '3118,1', access: 'R/W', comment: 'Comando modalità manuale' },
    { suffix: '.Command.Cmd_Man', type: 'Bool', address: '3118,3', access: 'R/W', comment: 'Comando start manuale' },
    { suffix: '.Status.Ready', type: 'Bool', address: '3128,0', access: 'R', comment: 'Utenza pronta' },
    { suffix: '.Status.Running', type: 'Bool', address: '3128,2', access: 'R', comment: 'Utenza in marcia' },
    { suffix: '.Status.Automatic', type: 'Bool', address: '3128,3', access: 'R', comment: 'Utenza in modalità automatica' },
    { suffix: '.Status.Manual', type: 'Bool', address: '3128,4', access: 'R', comment: 'Utenza in modalità manuale' },
    { suffix: '.Status.Selector', type: 'Bool', address: '3128,5', access: 'R', comment: 'Selettore utenza in remoto' },
    { suffix: '.Worktime.Reset', type: 'Bool', address: '3162,0', access: 'R/W', comment: 'Comando reset ore parziali utenza' },
    { suffix: '.Worktime.Total.Hour', type: 'DInt', address: '3164,0', access: 'R', comment: 'Ore totali', rawMin: 0, rawMax: 9999999, unit: 'Min', scalaMin: 0, scalaMax: 9999999 },
    { suffix: '.Worktime.Total.Min', type: 'Int', address: '3168,0', access: 'R', comment: 'Minuti totali', rawMin: 0, rawMax: 59, unit: 'Min', scalaMin: 0, scalaMax: 59 },
    { suffix: '.Worktime.Partial.Hour', type: 'DInt', address: '3172,0', access: 'R', comment: 'Ore Parziali', rawMin: 0, rawMax: 9999999, unit: 'Min', scalaMin: 0, scalaMax: 9999999 },
    { suffix: '.Worktime.Partial.Min', type: 'Int', address: '3176,0', access: 'R', comment: 'Minuti Parziali', rawMin: 0, rawMax: 59, unit: 'Min', scalaMin: 0, scalaMax: 59 }
  ],
  valve_inv: [
    { suffix: '.Command.Automatic', type: 'Bool', address: '2482,0', access: 'R/W', comment: 'Comando modalità automatica' },
    { suffix: '.Command.Manual', type: 'Bool', address: '2482,1', access: 'R/W', comment: 'Comando modalità manuale' },
    { suffix: '.Command.Cmd_Man_Open', type: 'Bool', address: '2482,3', access: 'R/W', comment: 'Comando manuale Apertura' },
    { suffix: '.Command.Cmd_Man_Close', type: 'Bool', address: '2484,0', access: 'R/W', comment: 'Comando manuale Chiusura' },
    { suffix: '.Status.Ready', type: 'Bool', address: '2492,0', access: 'R', comment: 'Utenza pronta' },
    { suffix: '.Status.Opening', type: 'Bool', address: '2492,2', access: 'R', comment: 'Utenza in apertura' },
    { suffix: '.Status.Closing', type: 'Bool', address: '2492,3', access: 'R', comment: 'Utenza in chiusura' },
    { suffix: '.Status.Automatic', type: 'Bool', address: '2492,4', access: 'R', comment: 'Utenza in modalità automatica' },
    { suffix: '.Status.Manual', type: 'Bool', address: '2492,5', access: 'R', comment: 'Utenza in modalità manuale' },
    { suffix: '.Status.Selector', type: 'Bool', address: '2494,0', access: 'R', comment: 'Selettore utenza in remoto' },
    { suffix: '.Status.Open', type: 'Bool', address: '2498,0', access: 'R', comment: 'Utenza aperta' },
    { suffix: '.Status.Close', type: 'Bool', address: '2502,0', access: 'R', comment: 'Utenza chiusa' }
  ],
  valve_noinv: [
    { suffix: '.Command.Automatic', type: 'Bool', address: '2482,0', access: 'R/W', comment: 'Comando modalità automatica' },
    { suffix: '.Command.Manual', type: 'Bool', address: '2482,1', access: 'R/W', comment: 'Comando modalità manuale' },
    { suffix: '.Command.Cmd_Man', type: 'Bool', address: '2482,3', access: 'R/W', comment: 'Comando start manuale' },
    { suffix: '.Status.Ready', type: 'Bool', address: '2492,0', access: 'R', comment: 'Utenza pronta' },
    { suffix: '.Status.Running', type: 'Bool', address: '2492,2', access: 'R', comment: 'Utenza in marcia' },
    { suffix: '.Status.Automatic', type: 'Bool', address: '2492,3', access: 'R', comment: 'Utenza in modalità automatica' },
    { suffix: '.Status.Manual', type: 'Bool', address: '2492,4', access: 'R', comment: 'Utenza in modalità manuale' },
    { suffix: '.Status.Selector', type: 'Bool', address: '2492,5', access: 'R', comment: 'Selettore utenza in remoto' },
    { suffix: '.Worktime.Reset', type: 'Bool', address: '2526,0', access: 'R/W', comment: 'Comando reset ore parziali utenza' },
    { suffix: '.Worktime.Total.Hour', type: 'DInt', address: '2528,0', access: 'R', comment: 'Ore totali', rawMin: 0, rawMax: 9999999, unit: 'Min', scalaMin: 0, scalaMax: 9999999 },
    { suffix: '.Worktime.Total.Min', type: 'Int', address: '2532,0', access: 'R', comment: 'Minuti totali', rawMin: 0, rawMax: 59, unit: 'Min', scalaMin: 0, scalaMax: 59 },
    { suffix: '.Worktime.Partial.Hour', type: 'DInt', address: '2536,0', access: 'R', comment: 'Ore Parziali', rawMin: 0, rawMax: 9999999, unit: 'Min', scalaMin: 0, scalaMax: 9999999 },
    { suffix: '.Worktime.Partial.Min', type: 'Int', address: '2540,0', access: 'R', comment: 'Minuti Parziali', rawMin: 0, rawMax: 59, unit: 'Min', scalaMin: 0, scalaMax: 59 }
  ]
};
// Helper per parsare indirizzi nel formato "word,bit"
function parseAddr(s) {
  if (!s || typeof s !== 'string') return { word: 0, bit: 0 };
  const p = String(s).split(',');
  return { word: parseInt(p[0], 10) || 0, bit: parseInt(p[1], 10) || 0 };
}

// Funzione per calcolare l'indirizzo sommando l'offset della sequenza all'indirizzo base
function addressFromSequence(baseAddress, seqKey, index) {
  // Definizione delle sequenze (devono corrispondere a quelle in ADDRESS_SEQUENCES)
  const ADDRESS_SEQUENCES = {
    'pump_inv': [
      '256,0','256,1','256,3','258,0','266,0','266,2','266,3','266,4','266,5','268,0','272,0','276,0','280,0','300,0','302,0','306,0','310,0','314,0'
    ],
    'pump_noinv': [
      '256,0','256,1','256,3','266,0','266,2','266,3','266,4','266,5','300,0','302,0','306,0','310,0','314,0'
    ],
    'valve_inv': [
      '256,0','256,1','256,3','258,0','266,0','266,2','266,3','266,4','266,5','268,0','272,0','276,0'
    ],
    'valve_noinv': [
      '256,0','256,1','256,3','266,0','266,2','266,3','266,4','266,5','300,0','302,0','306,0','310,0','314,0'
    ]
  };
  
  const seq = ADDRESS_SEQUENCES[seqKey];
  if (!seq || index < 0 || index >= seq.length) {
    console.warn('[addressFromSequence] Sequenza non trovata o indice fuori range:', { seqKey, index });
    return null;
  }
  
  // Parse dell'indirizzo base (può essere "3180" o "3180,0")
  const base = parseAddr(String(baseAddress).includes(',') ? baseAddress : `${baseAddress},0`);
  // Parse dell'offset dalla sequenza
  const offset = parseAddr(seq[index]);
  
  // Somma word e bit
  let word = base.word + offset.word;
  let bit = base.bit + offset.bit;
  
  // Gestione overflow dei bit (se >= 16, incrementa word)
  if (bit >= 16) {
    const carry = Math.floor(bit / 16);
    word += carry;
    bit = bit % 16;
  }
  
  // Gestione bit negativi (con prestito)
  if (bit < 0) {
    const borrow = Math.ceil(Math.abs(bit) / 16);
    word -= borrow;
    bit = ((bit % 16) + 16) % 16;
  }
  
  const result = `${word},${bit}`;
  console.log('[addressFromSequence]', { 
    seqKey, 
    index, 
    seqValue: seq[index], 
    baseAddress, 
    baseParsed: base,
    offsetParsed: offset,
    resultWord: word,
    resultBit: bit,
    result 
  });
  return result;
}
  </script>
</body>
</html>
